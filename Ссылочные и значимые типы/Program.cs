namespace Ссылочные_и_значимые_типы
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //reference & value types (значимый и ссылочный типа); Stack & Heap (Стак и куча)


            //Stack - это небольшой объём оперативной памяти, выделямый для каждого потока. По умолчанию = 1МБ (Переменные, действия над ними и вызов методов).
            //Нужен не только для хранения данных, но и для логики работы программы. Last in -> First out | Мало, но быстро
            //Содержит value types: struct, enum; Унаследованы у System.ValueType
            // Эти типы удаляются из оперативной памяти после покидания контекста, в котором требуются,
            //При копировании переменные передаются по значению (Копирование реальных данных)


            //Heap - это уже больший объём оперативной памяти, который мспользуется по мере надобности. По умолчанию на 32х разрядной = 1.5ГБ,
            //а если на 64х, то уже до 8ТБ | Много, но медленно
            //Cодержит reference types: class.
            //Удаляются при воздействии сборщика мусора
            //Копируется ссылка, оригинал и копия ссылаются на один и тот же объект в управляемой куче, на одни и те же данные | Ссылка хранится в стеке, а вот сами данные в куче

            //Чтобы отличить значимый от ссылочного типа, то требуется понять что перед нами: Структура, энам или же класс

            int a = 5; // Наводимся и видим в описании struct, значит это структура и это reference type 
            Random r = new Random(); // Наводимся на random и видим class, значит это value type

            int[] b = { 1, 2, 3 }; // Массив - это наследник абстрактного класса Array, а значит он является ссылочным типом, но при наведении на него мышкой будет
                                   // указано struct, это относится к элементам, хранящимся в этом массиве

            //ConsoleKey - пример enum'а

            Foo(a);

            Console.WriteLine(a); // Выведется 5 т.к. в методе Foo переменная a находится в контексте, а после его завершения удаляется из памяти, выходя из него

            int[] c = new int[1];

            c[0] = 1; //Изначальное значение

            Brr(c);

            Console.WriteLine(c[0]); //Выведет 9
        }

        static void Foo(int a)
        {
            a = 4; // Существует только для того момента, пока существует и работает функция Foo
        }

        static void Brr(int[] arr)
        {
            arr[0] = 9; // Прсваиваемое значение
        }
    }
}